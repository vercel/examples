# Testing

This example shows how to add unit, integration, and end-to-end (E2E) tests to a Next.js app, the setup can work for other frameworks as well.

## Demo

https://solutions-testing.vercel.app

## How to Use

You can choose from one of the following two methods to use this repository:

### One-Click Deploy

Deploy the example using [Vercel](https://vercel.com?utm_source=github&utm_medium=readme&utm_campaign=vercel-examples):

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/vercel/examples/tree/main/solutions/testing&project-name=testing&repository-name=testing)

### Clone and Deploy

Execute [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app) with [pnpm](https://pnpm.io/installation) to bootstrap the example:

```bash
pnpm create next-app --example https://github.com/vercel/examples/tree/main/solutions/testing testing
```

Before running tests locally, you'll need to install the browsers required to run the tests, which aren't installed by default by Plawright:

```bash
pnpm dlx playwright install
```

In the meantime, build and start the test server that will be used by the tests:

```bash
pnpm test-server
```

Deploy it to the cloud with [Vercel](https://vercel.com/new?utm_source=github&utm_medium=readme&utm_campaign=edge-middleware-eap) ([Documentation](https://nextjs.org/docs/deployment)).

## How it Works

- Integration and E2E tests with [Playwright](https://playwright.dev/docs/intro).
- Unit testing with [Jest](https://jestjs.io/). Visit the [Running Unit Tests](#running-unit-tests) section to learn more.
- [Visual testing](#visual-testing) with [AppliTools Eyes](https://applitools.com/platform/eyes/) and Playwright.
- Storybook for UI development. Visit the [Running Storybook](#running-storybook) section to learn more.

We use [Playwright](https://playwright.dev/docs/intro) for both integration and E2E tests. For unit testing Jest go to the [last section](#running-unit-tests).

### Integration vs E2E testing

Before going further, let's look at the difference between integration and E2E testing:

|                                    | Integration | End-to-end |
| ---------------------------------- | ----------- | ---------- |
| Test real user journeys            | ✅          | ✅         |
| Hit real APIs                      | ❌          | ✅         |
| Create and modify database records | ❌          | ✅         |
| Stable across test runs\*          | ✅          | ❌         |
| Fast execution time\*\*            | ✅          | ❌         |

> \* End-to-end tests can fail when APIs return unexpected responses or fail to respond, and when third parties have outages.
>
> \*\* Because integration tests don't hit the network or create/modify real database records, responses are immediate.

It's important to note that when building and running the app locally, static
and server-rendered pages are generated by hitting the network. Integration
tests can only intercept front-end network traffic.

### Choosing a testing strategy

In most cases, the default choice should be integration and visual tests. These are easier to write and maintain, and are both faster and more stable than E2E tests.

Stability and speed are important, as flaky or slow tests can slow down or even block merges and deployments.

We recommend that all pages are covered by integration and visual tests, and only critical flows be covered by E2E tests. When writing E2E tests, it's important to consider that each test is meant to create real database records, which may require cleanup.

### Visual testing

Visual tests are done with [AppliTools Eyes](https://applitools.com/platform/eyes/), which uses AI to better detect layout changes.

Applitools is disabled by default. To enable it, create a free account at [applitools.com](https://auth.applitools.com/users/register) get an API key.

Then, create the file `playwright/.env.local` and set the `APPLITOOLS_API_KEY` to your API key:

```bash
APPLITOOLS_API_KEY = <your api key>
```

Now, tests that use `eyes.check` will run a visual test in the Applitools dashboard too.

## Running Tests

### 1. Run the app in production mode

To run in production mode, use the following command:

```bash
pnpm test-server
```

This will provide the most stable environment, with some limitations:

- Building the app locally can be a slow process.
- You'll need to run build again for any code changes.

#### Why not run the app in development mode?

Whilst this allows you to quickly iterate on code, it has some notable limitations:

- Pages load much slower than they would normally, resulting in flaky test runs. This is normally only a problem for the first test run.
- Your code, and code from modules you rely on, can perform differently between production and development mode.

### 2a. Running integration tests

To run the integration test suite use the following command:

```bash
pnpm integration
```

### 2b. Running E2E tests

To run the E2E test suite use the following command:

```bash
pnpm e2e
```

### 2c. Running tests against a specific browser

Tests will run against multiple browsers by default, to run against a specific browser, use:

```bash
# Valid projects are `chromium`, `firefox`, `webkit`, etc.
# Any browser defined in playwright config is valid.
pnpm integration -- --project=chromium
```

Chromium is used quite often for writing and debugging tests so there's a shortcut for it:

```bash
pnpm integration -- --chromium
# or
pnpm integration -- -c
```

### 2d. Running tests against production

During testing a local server is expected to be running at http://localhost:3000. You could alternatively run the tests against the production server by adding the `BASE_URL` environment variable to the command:

```sh
BASE_URL="https://solutions-testing.vercel.app" pnpm integration
# or for E2E
BASE_URL="https://solutions-testing.vercel.app" pnpm e2e
```

### 2e. Running a single test or a single test file

Like most test-runners, Playwright supports [`.skip()`](https://playwright.dev/docs/api/class-test#test-skip-1) and [`.only()`](https://playwright.dev/docs/api/class-test#test-describe-only). Additionaly, you can run a single test by passing the filename to the command:

```bash
pnpm integration -- signup
# or for E2E
pnpm e2e -- signup
```

The command above will match `signup` with the tests in `tests/signup.spec.ts` and run them.

### 3. Running and debugging tests in VS Code

The [Playwright VSCode extension](https://marketplace.visualstudio.com/items?itemName=ms-playwright.playwright) can be used to run and debug tests all within VSCode.

You can use `Debug Test` to run a test (or a set of tests) in headed mode by right clicking a test name, and you can use `debugger` statements in your test(s) to pause at any point and inspect the page. Note that `page.pause()` doesn't work when running tests via this extension.

## Debugging Tests

Debugging is very useful when you want to debug a [single test or a single test file](#2e-running-a-single-test-or-a-single-test-file), read the section above for more details.

To run tests in headed mode ([`--headed`](https://playwright.dev/docs/test-cli#reference)) and have them pause on failure, run:

```bash
pnpm integration -- --chromium --pause-on-failure
# or
pnpm integration -- -c -p
```

> The `--chromium` argument is used because you'll usually debug against a single browser.

To debug tests step by step, add [`--debug`](https://playwright.dev/docs/debug#--debug) or [`PWDEBUG=1`](https://playwright.dev/docs/debug#pwdebug) to the command, like so:

```bash
pnpm integration -- --chromium --debug
# or
PWDEBUG=1 pnpm integration -- -c
```

### Watching for test changes

To re-run tests on file changes to `.spec.ts` files, add `--watch` like so:

```bash
pnpm integration -- --watch
# or
pnpm integration -- -w
```

#### Automatically open devtools on start

To automatically open the browser devtools in headed mode on test start, add the ENV variable `OPEN_DEVTOOLS`, like so:

```bash
OPEN_DEVTOOLS=1 pnpm integration -- -p
```

### Viewing test reports

Tests reports, including screenshots on error, are auto-generated and can be viewed by opening the HTML report file in `playwright/test-results/html-report`, or by running the following command:

```bash
pnpm --filter playwright exec playwright show-report test-results/html-report
```

### Viewing test traces

Along with screenshots, Playwright will also capture traces for failed tests.

You can view these by uploading them to [Playwright's Trace Viewer](https://trace.playwright.dev/) ([Docs](https://playwright.dev/docs/trace-viewer)) or by running the following command:

```bash
pnpm --filter playwright exec playwright show-trace test-results/output/[test-id]/trace.zip
```

### Spotting flaky tests

If you are having trouble working out why a test is flaky, you can try the [`--repeat-each <N>`](https://playwright.dev/docs/test-cli#reference) flag. This allows you to re-run a test multiple times in a short period of time, which should help identify flakiness:

```sh
# Run integration tests, repeating each test in `signup.spec.ts` 100 times.
pnpm integration -- --repeat-each 100 signup
# Run e2e tests, repeating each test in `signup.spec.ts` 100 times.
pnpm e2e -- --repeat-each 100 signup
```

## Running Unit Tests

To run the unit tests use the following command:

```bash
pnpm run test-unit
```

And to watch for changes:

```bash
pnpm run test-unit -- --watch
```

## Running Storybook

Run the following command from the root:

```bash
pnpm dev
```

The storybook server will be up and running at http://localhost:6006.

To build storybook and run it in production mode, use the following command:

```bash
pnpm build && pnpm start
```
