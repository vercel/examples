"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvaluationReason = void 0;
var DynamicConfig_1 = __importDefault(require("./DynamicConfig"));
var Layer_1 = __importDefault(require("./Layer"));
var BootstrapValidator_1 = __importDefault(require("./utils/BootstrapValidator"));
var Constants_1 = require("./utils/Constants");
var Hashing_1 = require("./utils/Hashing");
var StatsigAsyncStorage_1 = __importDefault(require("./utils/StatsigAsyncStorage"));
var StatsigLocalStorage_1 = __importDefault(require("./utils/StatsigLocalStorage"));
var EvaluationReason;
(function (EvaluationReason) {
    EvaluationReason["Network"] = "Network";
    EvaluationReason["Bootstrap"] = "Bootstrap";
    EvaluationReason["InvalidBootstrap"] = "InvalidBootstrap";
    EvaluationReason["Cache"] = "Cache";
    EvaluationReason["Prefetch"] = "Prefetch";
    EvaluationReason["Sticky"] = "Sticky";
    EvaluationReason["LocalOverride"] = "LocalOverride";
    EvaluationReason["Unrecognized"] = "Unrecognized";
    EvaluationReason["Uninitialized"] = "Uninitialized";
    EvaluationReason["Error"] = "Error";
})(EvaluationReason = exports.EvaluationReason || (exports.EvaluationReason = {}));
var MAX_USER_VALUE_CACHED = 10;
var StatsigStore = /** @class */ (function () {
    function StatsigStore(sdkInternal) {
        this.overrides = {
            gates: {},
            configs: {},
            layers: {},
        };
        this.sdkInternal = sdkInternal;
        this.userCacheKey = this.sdkInternal.getCurrentUserCacheKey();
        this.values = {};
        this.userValues = {
            feature_gates: {},
            dynamic_configs: {},
            sticky_experiments: {},
            layer_configs: {},
            has_updates: false,
            time: 0,
            evaluation_time: 0,
        };
        this.stickyDeviceExperiments = {};
        this.loaded = false;
        this.reason = EvaluationReason.Uninitialized;
        this.loadFromLocalStorage();
    }
    StatsigStore.prototype.updateUser = function (isUserPrefetched) {
        this.userCacheKey = this.sdkInternal.getCurrentUserCacheKey();
        return this.setUserValueFromCache(isUserPrefetched);
    };
    StatsigStore.prototype.loadFromAsyncStorage = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.parseCachedValues;
                        return [4 /*yield*/, StatsigAsyncStorage_1.default.getItemAsync(Constants_1.INTERNAL_STORE_KEY)];
                    case 1:
                        _b = [_c.sent()];
                        return [4 /*yield*/, StatsigAsyncStorage_1.default.getItemAsync(Constants_1.STICKY_DEVICE_EXPERIMENTS_KEY)];
                    case 2:
                        _a.apply(this, _b.concat([_c.sent()]));
                        // triggered for react native, when async storage is setup.  Need to update the cache key
                        // as the stableID is not available when this is set in the constructor (RN/async storage clients only)
                        this.userCacheKey = this.sdkInternal.getCurrentUserCacheKey();
                        this.loaded = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    StatsigStore.prototype.bootstrap = function (stableID, initializeValues) {
        var _a, _b, _c;
        var key = this.sdkInternal.getCurrentUserCacheKey();
        var user = this.sdkInternal.getCurrentUser();
        var reason = BootstrapValidator_1.default.isValid(user, initializeValues)
            ? EvaluationReason.Bootstrap
            : EvaluationReason.InvalidBootstrap;
        // clients are going to assume that the SDK is bootstraped after this method runs
        // if we fail to parse, we will fall back to defaults, but we dont want to throw
        // when clients try to check gates/configs/etc after this point
        this.loaded = true;
        try {
            this.userValues.feature_gates = (_a = initializeValues.feature_gates) !== null && _a !== void 0 ? _a : {};
            this.userValues.dynamic_configs = (_b = initializeValues.dynamic_configs) !== null && _b !== void 0 ? _b : {};
            this.userValues.layer_configs = (_c = initializeValues.layer_configs) !== null && _c !== void 0 ? _c : {};
            this.userValues.evaluation_time = Date.now();
            this.userValues.time = Date.now();
            this.values[key] = this.userValues;
            this.reason = reason;
            this.loadOverrides();
        }
        catch (_e) {
            return;
        }
    };
    StatsigStore.prototype.loadFromLocalStorage = function () {
        if (StatsigAsyncStorage_1.default.asyncStorage) {
            return;
        }
        this.parseCachedValues(StatsigLocalStorage_1.default.getItem(Constants_1.INTERNAL_STORE_KEY), StatsigLocalStorage_1.default.getItem(Constants_1.STICKY_DEVICE_EXPERIMENTS_KEY));
        this.loaded = true;
    };
    StatsigStore.prototype.isLoaded = function () {
        return this.loaded;
    };
    StatsigStore.prototype.getLastUpdateTime = function (user) {
        var userHash = (0, Hashing_1.getHashValue)(JSON.stringify(user));
        if (this.userValues.user_hash == userHash) {
            return this.userValues.time;
        }
        return null;
    };
    StatsigStore.prototype.parseCachedValues = function (allValues, deviceExperiments) {
        try {
            this.values = allValues ? JSON.parse(allValues) : this.values;
            this.setUserValueFromCache();
        }
        catch (e) {
            // Cached value corrupted, remove cache
            this.removeFromStorage(Constants_1.INTERNAL_STORE_KEY);
        }
        try {
            var deviceExpParsed = deviceExperiments
                ? JSON.parse(deviceExperiments)
                : null;
            if (deviceExpParsed) {
                this.stickyDeviceExperiments = deviceExpParsed;
            }
        }
        catch (e) {
            this.removeFromStorage(Constants_1.STICKY_DEVICE_EXPERIMENTS_KEY);
        }
        this.loadOverrides();
    };
    StatsigStore.prototype.setUserValueFromCache = function (isUserPrefetched) {
        if (isUserPrefetched === void 0) { isUserPrefetched = false; }
        var cachedValues = this.values[this.userCacheKey];
        if (cachedValues == null) {
            this.resetUserValues();
            this.reason = EvaluationReason.Uninitialized;
            return false;
        }
        this.userValues = cachedValues;
        this.reason = isUserPrefetched
            ? EvaluationReason.Prefetch
            : EvaluationReason.Cache;
        return true;
    };
    StatsigStore.prototype.removeFromStorage = function (key) {
        StatsigAsyncStorage_1.default.removeItemAsync(key);
        StatsigLocalStorage_1.default.removeItem(key);
    };
    StatsigStore.prototype.loadOverrides = function () {
        var overrides = StatsigLocalStorage_1.default.getItem(Constants_1.OVERRIDES_STORE_KEY);
        if (overrides != null) {
            try {
                this.overrides = JSON.parse(overrides);
            }
            catch (e) {
                StatsigLocalStorage_1.default.removeItem(Constants_1.OVERRIDES_STORE_KEY);
            }
        }
    };
    StatsigStore.prototype.save = function (user, jsonConfigs) {
        return __awaiter(this, void 0, void 0, function () {
            var requestedUserCacheKey, data, cacheKeys, _i, cacheKeys_1, key, prefetched, requestedUserValues, userHash, filteredValues;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestedUserCacheKey = (0, Hashing_1.getUserCacheKey)(this.sdkInternal.getStatsigMetadata().stableID, user);
                        data = jsonConfigs;
                        if (data.prefetched_user_values) {
                            cacheKeys = Object.keys(data.prefetched_user_values);
                            for (_i = 0, cacheKeys_1 = cacheKeys; _i < cacheKeys_1.length; _i++) {
                                key = cacheKeys_1[_i];
                                prefetched = data.prefetched_user_values[key];
                                this.values[key] = this.convertAPIDataToCacheValues(prefetched, key);
                            }
                        }
                        if (requestedUserCacheKey) {
                            requestedUserValues = this.convertAPIDataToCacheValues(data, requestedUserCacheKey);
                            if (data.has_updates && data.time) {
                                userHash = (0, Hashing_1.getHashValue)(JSON.stringify(user));
                                requestedUserValues.user_hash = userHash;
                            }
                            this.values[requestedUserCacheKey] = requestedUserValues;
                            if (requestedUserCacheKey == this.userCacheKey) {
                                this.userValues = requestedUserValues;
                                this.reason = EvaluationReason.Network;
                            }
                        }
                        filteredValues = Object.entries(this.values)
                            .sort(function (_a, _b) {
                            var a = _a[1];
                            var b = _b[1];
                            if (a == null) {
                                return 1;
                            }
                            if (b == null) {
                                return -1;
                            }
                            return (b === null || b === void 0 ? void 0 : b.time) - (a === null || a === void 0 ? void 0 : a.time);
                        })
                            .slice(0, MAX_USER_VALUE_CACHED);
                        this.values = Object.fromEntries(filteredValues);
                        if (!StatsigAsyncStorage_1.default.asyncStorage) return [3 /*break*/, 2];
                        return [4 /*yield*/, StatsigAsyncStorage_1.default.setItemAsync(Constants_1.INTERNAL_STORE_KEY, JSON.stringify(this.values))];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        StatsigLocalStorage_1.default.setItem(Constants_1.INTERNAL_STORE_KEY, JSON.stringify(this.values));
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    StatsigStore.prototype.checkGate = function (gateName, ignoreOverrides) {
        var _a;
        if (ignoreOverrides === void 0) { ignoreOverrides = false; }
        var gateNameHash = (0, Hashing_1.getHashValue)(gateName);
        var gateValue = {
            name: gateName,
            value: false,
            rule_id: '',
            secondary_exposures: [],
        };
        var details;
        if (!ignoreOverrides && this.overrides.gates[gateName] != null) {
            gateValue = {
                name: gateName,
                value: this.overrides.gates[gateName],
                rule_id: 'override',
                secondary_exposures: [],
            };
            details = this.getEvaluationDetails(false, EvaluationReason.LocalOverride);
        }
        else {
            var value = (_a = this.userValues) === null || _a === void 0 ? void 0 : _a.feature_gates[gateNameHash];
            if (value) {
                gateValue = value;
            }
            details = this.getEvaluationDetails(value != null);
        }
        return { evaluationDetails: details, gate: gateValue };
    };
    StatsigStore.prototype.getConfig = function (configName, ignoreOverrides) {
        var _a, _b;
        if (ignoreOverrides === void 0) { ignoreOverrides = false; }
        var configNameHash = (0, Hashing_1.getHashValue)(configName);
        var configValue;
        var details;
        if (!ignoreOverrides && this.overrides.configs[configName] != null) {
            details = this.getEvaluationDetails(false, EvaluationReason.LocalOverride);
            configValue = new DynamicConfig_1.default(configName, this.overrides.configs[configName], 'override', details);
        }
        else if (((_a = this.userValues) === null || _a === void 0 ? void 0 : _a.dynamic_configs[configNameHash]) != null) {
            var rawConfigValue = (_b = this.userValues) === null || _b === void 0 ? void 0 : _b.dynamic_configs[configNameHash];
            details = this.getEvaluationDetails(true);
            configValue = this.createDynamicConfig(configName, rawConfigValue, details);
        }
        else {
            details = this.getEvaluationDetails(false);
            configValue = new DynamicConfig_1.default(configName, {}, '', details);
        }
        return configValue;
    };
    StatsigStore.prototype.getExperiment = function (expName, keepDeviceValue, ignoreOverrides) {
        if (keepDeviceValue === void 0) { keepDeviceValue = false; }
        if (ignoreOverrides === void 0) { ignoreOverrides = false; }
        var exp;
        var details;
        if (!ignoreOverrides && this.overrides.configs[expName] != null) {
            details = this.getEvaluationDetails(false, EvaluationReason.LocalOverride);
            exp = new DynamicConfig_1.default(expName, this.overrides.configs[expName], 'override', details);
        }
        else {
            var latestValue = this.getLatestValue(expName, 'dynamic_configs');
            details = this.getEvaluationDetails(latestValue != null);
            var finalValue = this.getPossiblyStickyValue(expName, latestValue, keepDeviceValue, false /* isLayer */, details);
            exp = this.createDynamicConfig(expName, finalValue, details);
        }
        return exp;
    };
    StatsigStore.prototype.getLayer = function (logParameterFunction, layerName, keepDeviceValue) {
        var _a, _b, _c, _d;
        if (this.overrides.layers[layerName] != null) {
            var details_1 = this.getEvaluationDetails(false, EvaluationReason.LocalOverride);
            return Layer_1.default._create(layerName, (_a = this.overrides.layers[layerName]) !== null && _a !== void 0 ? _a : {}, 'override', details_1, logParameterFunction);
        }
        var latestValue = this.getLatestValue(layerName, 'layer_configs');
        var details = this.getEvaluationDetails(latestValue != null);
        var finalValue = this.getPossiblyStickyValue(layerName, latestValue, keepDeviceValue, true /* isLayer */, details);
        return Layer_1.default._create(layerName, (_b = finalValue === null || finalValue === void 0 ? void 0 : finalValue.value) !== null && _b !== void 0 ? _b : {}, (_c = finalValue === null || finalValue === void 0 ? void 0 : finalValue.rule_id) !== null && _c !== void 0 ? _c : '', details, logParameterFunction, finalValue === null || finalValue === void 0 ? void 0 : finalValue.secondary_exposures, finalValue === null || finalValue === void 0 ? void 0 : finalValue.undelegated_secondary_exposures, (_d = finalValue === null || finalValue === void 0 ? void 0 : finalValue.allocated_experiment_name) !== null && _d !== void 0 ? _d : '', finalValue === null || finalValue === void 0 ? void 0 : finalValue.explicit_parameters);
    };
    StatsigStore.prototype.overrideConfig = function (configName, value) {
        try {
            JSON.stringify(value);
        }
        catch (e) {
            console.warn('Failed to stringify given config override.  Dropping', e);
            return;
        }
        this.overrides.configs[configName] = value;
        this.saveOverrides();
    };
    StatsigStore.prototype.overrideLayer = function (layerName, value) {
        try {
            JSON.stringify(value);
        }
        catch (e) {
            console.warn('Failed to stringify given layer override.  Dropping', e);
            return;
        }
        this.overrides.layers[layerName] = value;
        this.saveOverrides();
    };
    StatsigStore.prototype.overrideGate = function (gateName, value) {
        this.overrides.gates[gateName] = value;
        this.saveOverrides();
    };
    StatsigStore.prototype.removeGateOverride = function (gateName) {
        if (gateName == null) {
            this.overrides.gates = {};
        }
        else {
            delete this.overrides.gates[gateName];
        }
        this.saveOverrides();
    };
    StatsigStore.prototype.removeConfigOverride = function (configName) {
        if (configName == null) {
            this.overrides.configs = {};
        }
        else {
            delete this.overrides.configs[configName];
        }
        this.saveOverrides();
    };
    StatsigStore.prototype.removeLayerOverride = function (layerName) {
        if (layerName == null) {
            this.overrides.layers = {};
        }
        else {
            delete this.overrides.layers[layerName];
        }
        this.saveOverrides();
    };
    StatsigStore.prototype.getAllOverrides = function () {
        return this.overrides;
    };
    StatsigStore.prototype.saveOverrides = function () {
        try {
            StatsigLocalStorage_1.default.setItem(Constants_1.OVERRIDES_STORE_KEY, JSON.stringify(this.overrides));
        }
        catch (e) {
            console.warn('Failed to persist gate/config overrides');
        }
    };
    StatsigStore.prototype.getLatestValue = function (name, topLevelKey) {
        var _a, _b, _c, _d, _f;
        var hash = (0, Hashing_1.getHashValue)(name);
        return ((_c = (_b = (_a = this.userValues) === null || _a === void 0 ? void 0 : _a[topLevelKey]) === null || _b === void 0 ? void 0 : _b[hash]) !== null && _c !== void 0 ? _c : (_f = (_d = this.userValues) === null || _d === void 0 ? void 0 : _d[topLevelKey]) === null || _f === void 0 ? void 0 : _f[name]);
    };
    // Sticky Logic: https://gist.github.com/daniel-statsig/3d8dfc9bdee531cffc96901c1a06a402
    StatsigStore.prototype.getPossiblyStickyValue = function (name, latestValue, keepDeviceValue, isLayer, details) {
        var _a;
        // We don't want sticky behavior. Clear any sticky values and return latest.
        if (!keepDeviceValue) {
            this.removeStickyValue(name);
            return latestValue;
        }
        // If there is no sticky value, save latest as sticky and return latest.
        var stickyValue = this.getStickyValue(name);
        if (!stickyValue) {
            this.attemptToSaveStickyValue(name, latestValue);
            return latestValue;
        }
        // Get the latest config value. Layers require a lookup by allocated_experiment_name.
        var latestExperimentValue = null;
        if (isLayer) {
            latestExperimentValue = this.getLatestValue((_a = stickyValue === null || stickyValue === void 0 ? void 0 : stickyValue.allocated_experiment_name) !== null && _a !== void 0 ? _a : '', 'dynamic_configs');
        }
        else {
            latestExperimentValue = latestValue;
        }
        if ((latestExperimentValue === null || latestExperimentValue === void 0 ? void 0 : latestExperimentValue.is_experiment_active) == true) {
            details.reason = EvaluationReason.Sticky;
            return stickyValue;
        }
        if ((latestValue === null || latestValue === void 0 ? void 0 : latestValue.is_experiment_active) == true) {
            this.attemptToSaveStickyValue(name, latestValue);
        }
        else {
            this.removeStickyValue(name);
        }
        return latestValue;
    };
    StatsigStore.prototype.createDynamicConfig = function (name, apiConfig, details) {
        var _a, _b, _c;
        return new DynamicConfig_1.default(name, (_a = apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.value) !== null && _a !== void 0 ? _a : {}, (_b = apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.rule_id) !== null && _b !== void 0 ? _b : '', details, apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.secondary_exposures, (_c = apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.allocated_experiment_name) !== null && _c !== void 0 ? _c : '');
    };
    StatsigStore.prototype.getStickyValue = function (name) {
        var _a, _b;
        var key = (0, Hashing_1.getHashValue)(name);
        return ((_b = (_a = this.userValues) === null || _a === void 0 ? void 0 : _a.sticky_experiments[key]) !== null && _b !== void 0 ? _b : this.stickyDeviceExperiments[key]);
    };
    StatsigStore.prototype.attemptToSaveStickyValue = function (name, config) {
        var _a;
        if (!config ||
            !config.is_user_in_experiment ||
            !config.is_experiment_active) {
            return;
        }
        var key = (0, Hashing_1.getHashValue)(name);
        if (config.is_device_based === true) {
            // save sticky values in memory
            this.stickyDeviceExperiments[key] = config;
        }
        else if ((_a = this.userValues) === null || _a === void 0 ? void 0 : _a.sticky_experiments) {
            this.userValues.sticky_experiments[key] = config;
        }
        // also save to persistent storage
        this.saveStickyValuesToStorage();
    };
    StatsigStore.prototype.removeStickyValue = function (name) {
        var _a, _b, _c, _d;
        if (Object.keys((_b = (_a = this.userValues) === null || _a === void 0 ? void 0 : _a.sticky_experiments) !== null && _b !== void 0 ? _b : {}).length === 0 &&
            Object.keys((_c = this.stickyDeviceExperiments) !== null && _c !== void 0 ? _c : {}).length === 0) {
            return;
        }
        var key = (0, Hashing_1.getHashValue)(name);
        (_d = this.userValues) === null || _d === void 0 ? true : delete _d.sticky_experiments[key];
        delete this.stickyDeviceExperiments[key];
        this.saveStickyValuesToStorage();
    };
    StatsigStore.prototype.saveStickyValuesToStorage = function () {
        this.values[this.userCacheKey] = this.userValues;
        this.setItemToStorage(Constants_1.INTERNAL_STORE_KEY, JSON.stringify(this.values));
        this.setItemToStorage(Constants_1.STICKY_DEVICE_EXPERIMENTS_KEY, JSON.stringify(this.stickyDeviceExperiments));
    };
    StatsigStore.prototype.getGlobalEvaluationDetails = function () {
        var _a, _b;
        return {
            reason: (_a = this.reason) !== null && _a !== void 0 ? _a : EvaluationReason.Uninitialized,
            time: (_b = this.userValues.evaluation_time) !== null && _b !== void 0 ? _b : 0,
        };
    };
    StatsigStore.prototype.getEvaluationDetails = function (valueExists, reasonOverride) {
        var _a;
        if (valueExists) {
            return {
                reason: this.reason,
                time: (_a = this.userValues.evaluation_time) !== null && _a !== void 0 ? _a : Date.now(),
            };
        }
        else {
            return {
                reason: reasonOverride !== null && reasonOverride !== void 0 ? reasonOverride : (this.reason == EvaluationReason.Uninitialized
                    ? EvaluationReason.Uninitialized
                    : EvaluationReason.Unrecognized),
                time: Date.now(),
            };
        }
    };
    StatsigStore.prototype.resetUserValues = function () {
        this.userValues = {
            feature_gates: {},
            dynamic_configs: {},
            sticky_experiments: {},
            layer_configs: {},
            time: 0,
            evaluation_time: 0,
        };
    };
    StatsigStore.prototype.convertAPIDataToCacheValues = function (data, cacheKey) {
        var _a, _b;
        // Specifically pulling keys from data here to avoid pulling in unwanted keys
        return {
            feature_gates: data.feature_gates,
            layer_configs: data.layer_configs,
            dynamic_configs: data.dynamic_configs,
            sticky_experiments: (_b = (_a = this.values[cacheKey]) === null || _a === void 0 ? void 0 : _a.sticky_experiments) !== null && _b !== void 0 ? _b : {},
            time: data.time == null || isNaN(data.time) ? 0 : data.time,
            evaluation_time: Date.now(),
        };
    };
    StatsigStore.prototype.setItemToStorage = function (key, value) {
        if (StatsigAsyncStorage_1.default.asyncStorage) {
            StatsigAsyncStorage_1.default.setItemAsync(key, value);
        }
        else {
            StatsigLocalStorage_1.default.setItem(key, value);
        }
    };
    return StatsigStore;
}());
exports.default = StatsigStore;
