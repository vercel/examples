"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var Errors_1 = require("../Errors");
var core_1 = require("./core");
var Dispatcher_1 = __importDefault(require("./Dispatcher"));
var safeFetch_1 = __importDefault(require("./safeFetch"));
var uuidv4 = require('uuid').v4;
var retryStatusCodes = [408, 500, 502, 503, 504, 522, 524, 599];
var StatsigFetcher = /** @class */ (function () {
    function StatsigFetcher(secretKey, options) {
        this.sessionID = uuidv4();
        this.leakyBucket = {};
        this.pendingTimers = [];
        this.dispatcher = new Dispatcher_1["default"](200);
        this.localMode = options.localMode;
        this.sdkKey = secretKey;
    }
    StatsigFetcher.prototype.dispatch = function (url, body, timeout) {
        return this.dispatcher.enqueue(this.post(url, body), timeout);
    };
    StatsigFetcher.prototype.post = function (url, body, retries, backoff) {
        var _this = this;
        if (retries === void 0) { retries = 0; }
        if (backoff === void 0) { backoff = 1000; }
        if (this.localMode) {
            return Promise.reject(new Errors_1.StatsigLocalModeNetworkError());
        }
        var counter = this.leakyBucket[url];
        if (counter != null && counter >= 1000) {
            return Promise.reject(new Errors_1.StatsigTooManyRequestsError('Request failed because you are making the same request too frequently.'));
        }
        if (counter == null) {
            this.leakyBucket[url] = 1;
        }
        else {
            this.leakyBucket[url] = counter + 1;
        }
        var params = {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-type': 'application/json; charset=UTF-8',
                'STATSIG-API-KEY': this.sdkKey,
                'STATSIG-CLIENT-TIME': Date.now(),
                'STATSIG-SERVER-SESSION-ID': this.sessionID,
                'STATSIG-SDK-TYPE': (0, core_1.getSDKType)(),
                'STATSIG-SDK-VERSION': (0, core_1.getSDKVersion)()
            }
        };
        return (0, safeFetch_1["default"])(url, params)
            .then(function (res) {
            if ((!res.ok || retryStatusCodes.includes(res.status)) && retries > 0) {
                return _this._retry(url, body, retries, backoff);
            }
            else if (!res.ok) {
                return Promise.reject(new Error('Request to ' + url + ' failed with status ' + res.status));
            }
            return Promise.resolve(res);
        })["catch"](function (e) {
            if (retries > 0) {
                return _this._retry(url, body, retries, backoff);
            }
            return Promise.reject(e);
        })["finally"](function () {
            _this.leakyBucket[url] = Math.max(_this.leakyBucket[url] - 1, 0);
        });
    };
    StatsigFetcher.prototype.shutdown = function () {
        if (this.pendingTimers != null) {
            this.pendingTimers.forEach(function (timer) {
                if (timer != null) {
                    clearTimeout(timer);
                }
            });
        }
        if (this.dispatcher != null) {
            this.dispatcher.shutdown();
        }
    };
    StatsigFetcher.prototype._retry = function (url, body, retries, backoff) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.pendingTimers.push(setTimeout(function () {
                _this.leakyBucket[url] = Math.max(_this.leakyBucket[url] - 1, 0);
                _this.post(url, body, retries - 1, backoff * 10)
                    .then(resolve)["catch"](reject);
            }, backoff).unref());
        });
    };
    return StatsigFetcher;
}());
exports["default"] = StatsigFetcher;
